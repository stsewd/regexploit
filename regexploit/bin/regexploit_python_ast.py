#!/usr/bin/env python
import argparse
import ast
import logging
import re
import traceback
import json
import warnings

from regexploit.ast.sre import SreOpParser, UnsupportedSreOpException
from regexploit.bin.files import file_generator
from regexploit.languages.python_node_visitor import PythonNodeVisitor
from regexploit.output.text import TextOutput
from regexploit.redos import find


def handle_file(filename: str, output: TextOutput, extract: bool = False) -> list[dict]:
    with open(filename, "rb") as f:
        code = f.read()
    try:
        code_ast = ast.parse(code)
        pnv = PythonNodeVisitor()
        pnv.visit(code_ast)
    except RecursionError:
        print(f"RecursionError parsing AST for {filename}")
        return []
    except SyntaxError as e:
        print(f"Bad Python3 syntax in {filename}: {e}")
        return []
    regexes = []
    for regex in pnv.patterns:
        regex_dict = {
            "filename": filename,
            "lineno": regex.lineno,
            "pattern": regex.pattern,
            "flags": regex.flags,
            "vulnerable": "unknown",
            "redos": [],
        }
        try:
            parsed = SreOpParser().parse_sre(regex.pattern, regex.flags)
        except re.error:
            continue  # We will have many strings which aren't actually regexes
        except UnsupportedSreOpException as e:
            print(f"Error parsing regex {regex.pattern} from {filename}: {e}")
            continue
        try:
            output.next()
            for redos in find(parsed):
                if redos.starriness > 2:
                    regex_dict["vulnerable"] = True
                    regex_dict["redos"].append({
                        "starriness": redos.starriness,
                        "degree": redos.degree,
                        "repeated_character": redos.repeated_character,
                        "example": redos.example(),
                    })
                    context = None
                    try:
                        context = code.splitlines()[regex.lineno - 1].decode().strip()
                    except UnicodeDecodeError:
                        pass
                    output.record(
                        redos,
                        regex.pattern,
                        filename=filename,
                        lineno=regex.lineno,
                        context=context,
                    )
        except Exception:
            print(
                f"Error finding ReDoS: {regex.pattern} from {filename} #{regex.lineno}"
            )
            print(traceback.format_exc())
        else:
            if regex_dict["vulnerable"] == 'unknown':
                regex_dict["vulnerable"] = False

        if extract:
            regexes.append(regex_dict)
    return regexes


def main():
    with warnings.catch_warnings():
        # Some weird regexes emit warnings
        warnings.simplefilter("ignore", category=FutureWarning)
        warnings.simplefilter("ignore", category=DeprecationWarning)
        parser = argparse.ArgumentParser(
            description="Parse regexes out of python files and scan them for ReDoS"
        )
        parser.add_argument("files", nargs="+", help="Python files or directories")
        parser.add_argument(
            "--glob", action="store_true", help="Glob the input filenames (**/*)"
        )
        parser.add_argument("--verbose", action="store_true", help="Verbose logging")
        parser.add_argument(
            "--ignore", action="append", help="Paths containing this string are ignored"
        )
        parser.add_argument(
            "--extract", help="Extract regexes to a file in JSON format"
        )
        args = parser.parse_args()

        if args.verbose:
            logging.basicConfig(level=logging.DEBUG)

        files = file_generator(args.files, args.glob, ["*.py"], args.ignore)
        output = TextOutput()
        regexes = []
        extract = bool(args.extract)
        for filename in files:
            logging.debug(filename)
            regexes.extend(handle_file(filename, output, extract=extract))
        print(f"Processed {output.regexes} regexes")
        if extract:
            with open(args.extract, "w") as f:
                json.dump(regexes, f)


if __name__ == "__main__":
    main()
